/**
 * generated by Xtext 2.10.0
 */
package de.cau.cs.se.geco.architecture.scoping;

import com.google.common.base.Objects;
import com.google.inject.Inject;
import com.google.inject.name.Named;
import de.cau.cs.se.geco.architecture.architecture.ConstraintExpression;
import de.cau.cs.se.geco.architecture.architecture.GecoModel;
import de.cau.cs.se.geco.architecture.architecture.Generator;
import de.cau.cs.se.geco.architecture.architecture.Import;
import de.cau.cs.se.geco.architecture.architecture.InstanceOf;
import de.cau.cs.se.geco.architecture.architecture.Model;
import de.cau.cs.se.geco.architecture.architecture.ModelSequence;
import de.cau.cs.se.geco.architecture.architecture.ModelType;
import de.cau.cs.se.geco.architecture.architecture.NodeProperty;
import de.cau.cs.se.geco.architecture.architecture.NodeSetRelation;
import de.cau.cs.se.geco.architecture.architecture.NodeType;
import de.cau.cs.se.geco.architecture.architecture.RegisteredRootClass;
import de.cau.cs.se.geco.architecture.architecture.SourceModelSelector;
import de.cau.cs.se.geco.architecture.architecture.TargetModel;
import de.cau.cs.se.geco.architecture.architecture.TraceModelReference;
import de.cau.cs.se.geco.architecture.architecture.Weaver;
import de.cau.cs.se.geco.architecture.framework.IGenerator;
import de.cau.cs.se.geco.architecture.framework.IWeaver;
import de.cau.cs.se.geco.architecture.framework.IWeaverSeparatePointcut;
import de.cau.cs.se.geco.architecture.scoping.AbstractArchitectureScopeProvider;
import de.cau.cs.se.geco.architecture.scoping.JvmImportTypeScope;
import de.cau.cs.se.geco.architecture.scoping.JvmMemberTypeScope;
import de.cau.cs.se.geco.architecture.scoping.JvmRegisterMetamodelImportScope;
import de.cau.cs.se.geco.architecture.typing.ArchitectureTyping;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.xtext.common.types.JvmDeclaredType;
import org.eclipse.xtext.common.types.JvmGenericType;
import org.eclipse.xtext.common.types.JvmMember;
import org.eclipse.xtext.common.types.JvmOperation;
import org.eclipse.xtext.common.types.JvmType;
import org.eclipse.xtext.common.types.access.IJvmTypeProvider;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.IScopeProvider;
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider;
import org.eclipse.xtext.scoping.impl.IDelegatingScopeProvider;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
@SuppressWarnings("all")
public class ArchitectureScopeProvider extends AbstractArchitectureScopeProvider implements IDelegatingScopeProvider {
  @Inject
  private IJvmTypeProvider.Factory typeProviderFactory;
  
  @Inject
  @Named(AbstractDeclarativeScopeProvider.NAMED_DELEGATE)
  private IScopeProvider delegate;
  
  @Override
  public IScope getScope(final EObject context, final EReference reference) {
    IScope _switchResult = null;
    boolean _matched = false;
    if (context instanceof NodeProperty) {
      boolean _equals = reference.getName().equals("property");
      if (_equals) {
        _matched=true;
        _switchResult = this.createPropertyScope(((NodeProperty)context).eContainer(), reference);
      }
    }
    if (!_matched) {
      if (context instanceof Generator) {
        boolean _equals = reference.getName().equals("reference");
        if (_equals) {
          _matched=true;
          _switchResult = this.createGeneratorReferenceScope(((Generator)context), reference);
        }
      }
    }
    if (!_matched) {
      if (context instanceof Weaver) {
        boolean _equals = reference.getName().equals("reference");
        if (_equals) {
          _matched=true;
          _switchResult = this.createWeaverReferenceScope(((Weaver)context), reference);
        }
      }
    }
    if (!_matched) {
      if (context instanceof NodeType) {
        _matched=true;
        _switchResult = this.createNodeTypeScope(((NodeType)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof InstanceOf) {
        _matched=true;
        _switchResult = this.createInstanceOfScope(((InstanceOf)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof Generator) {
        boolean _equals = reference.getName().equals("readTraceModels");
        if (_equals) {
          _matched=true;
        }
      }
      if (!_matched) {
        if (context instanceof TraceModelReference) {
          _matched=true;
        }
      }
      if (!_matched) {
        if (context instanceof Import) {
          _matched=true;
        }
      }
      if (!_matched) {
        if (context instanceof ModelType) {
          _matched=true;
        }
      }
      if (!_matched) {
        if (context instanceof RegisteredRootClass) {
          _matched=true;
        }
      }
      if (!_matched) {
        if (context instanceof SourceModelSelector) {
          _matched=true;
        }
      }
      if (!_matched) {
        if (context instanceof TargetModel) {
          _matched=true;
        }
      }
      if (_matched) {
        _switchResult = this.delegate.getScope(context, reference);
      }
    }
    if (!_matched) {
      {
        System.out.println((((">> " + context) + " ") + reference));
        Class<? extends EObject> _class = context.getClass();
        String _plus = ("No scope available for " + _class);
        throw new UnsupportedOperationException(_plus);
      }
    }
    return _switchResult;
  }
  
  @Override
  public IScopeProvider getDelegate() {
    return this.delegate;
  }
  
  /**
   * Create scope for property.
   */
  private IScope createPropertyScope(final EObject container, final EReference reference) {
    IScope _switchResult = null;
    boolean _matched = false;
    if (container instanceof ModelType) {
      _matched=true;
      _switchResult = this.createJvmDeclaredTypeScope(((ModelType)container).getTarget().getImportedNamespace(), reference);
    }
    if (!_matched) {
      if (container instanceof NodeProperty) {
        _matched=true;
        JvmMember _property = ((NodeProperty)container).getProperty();
        _switchResult = this.createJvmDeclaredTypeScope(((JvmOperation) _property).getReturnType().getType(), reference);
      }
    }
    if (!_matched) {
      if (container instanceof SourceModelSelector) {
        _matched=true;
        EObject _eContainer = ((SourceModelSelector)container).getReference().eContainer();
        final JvmType genericType = ArchitectureTyping.determineElementType(ArchitectureTyping.resolveType(((ModelSequence) _eContainer).getType()));
        ConstraintExpression _constraint = ((SourceModelSelector)container).getConstraint();
        boolean _tripleNotEquals = (_constraint != null);
        if (_tripleNotEquals) {
          ConstraintExpression _constraint_1 = ((SourceModelSelector)container).getConstraint();
          if ((_constraint_1 instanceof InstanceOf)) {
            ConstraintExpression _constraint_2 = ((SourceModelSelector)container).getConstraint();
            return this.createJvmDeclaredTypeScope(((InstanceOf) _constraint_2).getType(), reference);
          }
        }
        return this.createJvmDeclaredTypeScope(genericType, reference);
      }
    }
    if (!_matched) {
      _switchResult = IScope.NULLSCOPE;
    }
    return _switchResult;
  }
  
  /**
   * Create scope of JvmDeclareType for its member (getters for features).
   */
  private IScope createJvmDeclaredTypeScope(final JvmType type, final EReference reference) {
    IScope _switchResult = null;
    boolean _matched = false;
    if (type instanceof JvmDeclaredType) {
      _matched=true;
      _switchResult = new JvmMemberTypeScope(((JvmDeclaredType)type));
    }
    if (!_matched) {
      _switchResult = IScope.NULLSCOPE;
    }
    return _switchResult;
  }
  
  /**
   * Scope for generators.
   */
  private IScope createGeneratorReferenceScope(final Generator context, final EReference reference) {
    final Function1<Import, Boolean> _function = (Import it) -> {
      return this.implementsInterface(it.getImportedNamespace(), context, IGenerator.class.getName());
    };
    Iterable<Import> _filter = IterableExtensions.<Import>filter(this.getModelRoot(context).getImports(), _function);
    return new JvmImportTypeScope(_filter);
  }
  
  /**
   * Scope for weavers.
   */
  private IScope createWeaverReferenceScope(final Weaver context, final EReference reference) {
    final Function1<Import, Boolean> _function = (Import it) -> {
      return Boolean.valueOf(((this.implementsInterface(it.getImportedNamespace(), context, IWeaver.class.getName())).booleanValue() || 
        (this.implementsInterface(it.getImportedNamespace(), context, IWeaverSeparatePointcut.class.getName())).booleanValue()));
    };
    Iterable<Import> _filter = IterableExtensions.<Import>filter(this.getModelRoot(context).getImports(), _function);
    return new JvmImportTypeScope(_filter);
  }
  
  /**
   * Scope for the trace model scope.
   */
  private IScope createNodeTypeScope(final NodeType nodeType, final EReference reference) {
    IScope _xblockexpression = null;
    {
      final Generator generator = this.getGeneratorContextNode(nodeType);
      IScope _xifexpression = null;
      EObject _eContainer = nodeType.eContainer();
      final Function1<NodeType, Boolean> _function = (NodeType it) -> {
        return Boolean.valueOf(it.equals(nodeType));
      };
      boolean _exists = IterableExtensions.<NodeType>exists(((NodeSetRelation) _eContainer).getSourceNodes(), _function);
      if (_exists) {
        Model _reference = generator.getSourceModel().getReference();
        boolean _tripleNotEquals = (_reference != null);
        if (_tripleNotEquals) {
          JvmType _determineElementType = ArchitectureTyping.determineElementType(ArchitectureTyping.resolveType(generator.getSourceModel().getReference()));
          ResourceSet _resourceSet = this.getModelRoot(nodeType).eResource().getResourceSet();
          return new JvmRegisterMetamodelImportScope(_determineElementType, _resourceSet, this.typeProviderFactory);
        } else {
          return IScope.NULLSCOPE;
        }
      } else {
        IScope _xifexpression_1 = null;
        TargetModel _targetModel = generator.getTargetModel();
        boolean _tripleEquals = (_targetModel == null);
        if (_tripleEquals) {
          IScope _xifexpression_2 = null;
          EObject _eContainer_1 = generator.eContainer();
          if ((_eContainer_1 instanceof Weaver)) {
            EObject _eContainer_2 = generator.eContainer();
            final SourceModelSelector sourceModel = ArchitectureTyping.resolveWeaverSourceModel(((Weaver) _eContainer_2));
            if ((sourceModel != null)) {
              JvmType _determineElementType_1 = ArchitectureTyping.determineElementType(ArchitectureTyping.resolveType(sourceModel.getReference()));
              ResourceSet _resourceSet_1 = this.getModelRoot(nodeType).eResource().getResourceSet();
              return new JvmRegisterMetamodelImportScope(_determineElementType_1, _resourceSet_1, this.typeProviderFactory);
            } else {
              return IScope.NULLSCOPE;
            }
          } else {
            _xifexpression_2 = IScope.NULLSCOPE;
          }
          _xifexpression_1 = _xifexpression_2;
        } else {
          JvmType _determineElementType_2 = ArchitectureTyping.determineElementType(ArchitectureTyping.resolveType(generator.getTargetModel().getReference()));
          ResourceSet _resourceSet_2 = this.getModelRoot(nodeType).eResource().getResourceSet();
          return new JvmRegisterMetamodelImportScope(_determineElementType_2, _resourceSet_2, this.typeProviderFactory);
        }
        _xifexpression = _xifexpression_1;
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  /**
   * Scope for the type of call.
   */
  private IScope createInstanceOfScope(final InstanceOf type, final EReference reference) {
    IScope _xblockexpression = null;
    {
      final JvmType context = this.getMetaModelContextNode(type);
      IScope _xifexpression = null;
      if ((context != null)) {
        ResourceSet _resourceSet = this.getModelRoot(type).eResource().getResourceSet();
        return new JvmRegisterMetamodelImportScope(context, _resourceSet, 
          this.typeProviderFactory);
      } else {
        _xifexpression = IScope.NULLSCOPE;
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  private GecoModel getModelRoot(final EObject object) {
    try {
      GecoModel _xblockexpression = null;
      {
        final EObject container = object.eContainer();
        GecoModel _switchResult = null;
        boolean _matched = false;
        if (container instanceof GecoModel) {
          _matched=true;
          return ((GecoModel)container);
        }
        if (!_matched) {
          if (Objects.equal(container, null)) {
            _matched=true;
            throw new Exception("Corrupted model: No Model node.");
          }
        }
        if (!_matched) {
          _switchResult = this.getModelRoot(container);
        }
        _xblockexpression = _switchResult;
      }
      return _xblockexpression;
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  private JvmType getMetaModelContextNode(final EObject type) {
    try {
      JvmType _xblockexpression = null;
      {
        final EObject container = type.eContainer();
        JvmType _switchResult = null;
        boolean _matched = false;
        if (container instanceof NodeProperty) {
          _matched=true;
          return ArchitectureTyping.determineElementType(ArchitectureTyping.resolveType(((NodeProperty)container).getProperty()));
        }
        if (!_matched) {
          if (container instanceof SourceModelSelector) {
            _matched=true;
            return ArchitectureTyping.determineElementType(ArchitectureTyping.resolveType(((SourceModelSelector)container).getReference()));
          }
        }
        if (!_matched) {
          if (Objects.equal(container, null)) {
            _matched=true;
            throw new Exception("Corrupted model: Cannot find NodeProperty or SourceModelNodeSelector context.");
          }
        }
        if (!_matched) {
          _switchResult = this.getMetaModelContextNode(type.eContainer());
        }
        _xblockexpression = _switchResult;
      }
      return _xblockexpression;
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  private Generator getGeneratorContextNode(final EObject type) {
    try {
      Generator _xblockexpression = null;
      {
        final EObject container = type.eContainer();
        Generator _switchResult = null;
        boolean _matched = false;
        if (container instanceof Generator) {
          _matched=true;
          return ((Generator)container);
        }
        if (!_matched) {
          if (Objects.equal(container, null)) {
            _matched=true;
            throw new Exception("Corrupted model: Cannot find Generator context.");
          }
        }
        if (!_matched) {
          _switchResult = this.getGeneratorContextNode(type.eContainer());
        }
        _xblockexpression = _switchResult;
      }
      return _xblockexpression;
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  /**
   * Check if the given JvmType implements the interface specified by typeName.
   */
  private Boolean implementsInterface(final JvmType type, final EObject object, final String typeName) {
    boolean _xblockexpression = false;
    {
      final JvmType matchingType = this.typeProviderFactory.createTypeProvider(object.eResource().getResourceSet()).findTypeByName(typeName);
      boolean _switchResult = false;
      boolean _matched = false;
      if (type instanceof JvmGenericType) {
        _matched=true;
        _switchResult = ArchitectureTyping.isSubTypeOf(((JvmGenericType)type), matchingType);
      }
      if (!_matched) {
        _switchResult = false;
      }
      _xblockexpression = _switchResult;
    }
    return Boolean.valueOf(_xblockexpression);
  }
}
