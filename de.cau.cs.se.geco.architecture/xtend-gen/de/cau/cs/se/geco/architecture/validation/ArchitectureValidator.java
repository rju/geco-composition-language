/**
 * generated by Xtext 2.10.0
 */
package de.cau.cs.se.geco.architecture.validation;

import de.cau.cs.se.geco.architecture.architecture.ArchitecturePackage;
import de.cau.cs.se.geco.architecture.architecture.Generator;
import de.cau.cs.se.geco.architecture.architecture.TargetModel;
import de.cau.cs.se.geco.architecture.architecture.Weaver;
import de.cau.cs.se.geco.architecture.framework.IWeaver;
import de.cau.cs.se.geco.architecture.framework.IWeaverSeparatePointcut;
import de.cau.cs.se.geco.architecture.typing.ArchitectureTyping;
import de.cau.cs.se.geco.architecture.validation.AbstractArchitectureValidator;
import org.eclipse.xtext.common.types.JvmGenericType;
import org.eclipse.xtext.common.types.JvmParameterizedTypeReference;
import org.eclipse.xtext.common.types.JvmType;
import org.eclipse.xtext.common.types.JvmTypeReference;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class ArchitectureValidator extends AbstractArchitectureValidator {
  @Check
  public void checkWeaverSourceModelType(final Weaver weaver) {
    final JvmType weaverJvmType = weaver.getReference();
    boolean _matched = false;
    if (weaverJvmType instanceof JvmGenericType) {
      _matched=true;
      final Function1<JvmTypeReference, Boolean> _function = (JvmTypeReference it) -> {
        return Boolean.valueOf((it.getType().getQualifiedName().equals(IWeaver.class.getCanonicalName()) || 
          it.getType().getQualifiedName().equals(IWeaverSeparatePointcut.class.getCanonicalName())));
      };
      final Iterable<JvmTypeReference> match = IterableExtensions.<JvmTypeReference>filter(((JvmGenericType)weaverJvmType).getSuperTypes(), _function);
      int _size = IterableExtensions.size(match);
      boolean _greaterThan = (_size > 0);
      if (_greaterThan) {
        Object _get = ((Object[])Conversions.unwrapArray(match, Object.class))[0];
        if ((_get instanceof JvmParameterizedTypeReference)) {
          JvmTypeReference _get_1 = ((JvmTypeReference[])Conversions.unwrapArray(match, JvmTypeReference.class))[0];
          final JvmParameterizedTypeReference iface = ((JvmParameterizedTypeReference) _get_1);
          final JvmTypeReference baseTypeReference = iface.getArguments().get(0);
          final JvmTypeReference sourceModelTypeReference = ArchitectureTyping.resolveType(ArchitectureTyping.resolveWeaverSourceModel(weaver));
          boolean _isSubTypeOf = ArchitectureTyping.isSubTypeOf(sourceModelTypeReference, baseTypeReference);
          boolean _not = (!_isSubTypeOf);
          if (_not) {
            boolean _isSubTypeOf_1 = ArchitectureTyping.isSubTypeOf(ArchitectureTyping.resolveType(ArchitectureTyping.determineElementType(sourceModelTypeReference)), baseTypeReference);
            boolean _not_1 = (!_isSubTypeOf_1);
            if (_not_1) {
              String _qualifiedName = sourceModelTypeReference.getQualifiedName();
              String _plus = ("Source model type " + _qualifiedName);
              String _plus_1 = (_plus + 
                " does not match weaver base type ");
              String _qualifiedName_1 = baseTypeReference.getQualifiedName();
              String _plus_2 = (_plus_1 + _qualifiedName_1);
              this.error(_plus_2, 
                ArchitecturePackage.Literals.FRAGMENT__SOURCE_MODEL);
            }
          }
        }
      } else {
        String _qualifiedName_2 = ((JvmGenericType)weaverJvmType).getQualifiedName();
        String _plus_3 = ("Weaver expected, but " + _qualifiedName_2);
        String _plus_4 = (_plus_3 + " found.");
        this.error(_plus_4, 
          ArchitecturePackage.Literals.FRAGMENT__REFERENCE);
      }
    }
    if (!_matched) {
      this.error("Weaver expected, but illegal type found. Please check for build failures.", 
        ArchitecturePackage.Literals.FRAGMENT__REFERENCE);
    }
  }
  
  @Check
  public void checkGeneratorSourceModelType(final Generator generator) {
    final JvmType generatorJvmType = generator.getReference();
    boolean _matched = false;
    if (generatorJvmType instanceof JvmGenericType) {
      _matched=true;
      final Function1<JvmTypeReference, Boolean> _function = (JvmTypeReference it) -> {
        return Boolean.valueOf(it.getType().getSimpleName().equals("IGenerator"));
      };
      final Iterable<JvmTypeReference> match = IterableExtensions.<JvmTypeReference>filter(((JvmGenericType)generatorJvmType).getSuperTypes(), _function);
      int _size = IterableExtensions.size(match);
      boolean _greaterThan = (_size > 0);
      if (_greaterThan) {
        Object _get = ((Object[])Conversions.unwrapArray(match, Object.class))[0];
        if ((_get instanceof JvmParameterizedTypeReference)) {
          final JvmTypeReference inputTypeReference = ArchitectureTyping.determineGeneratorInputType(((JvmGenericType)generatorJvmType));
          final JvmTypeReference sourceModelTypeReference = ArchitectureTyping.resolveType(generator.getSourceModel());
          if ((sourceModelTypeReference != null)) {
            boolean _isSubTypeOf = ArchitectureTyping.isSubTypeOf(sourceModelTypeReference, inputTypeReference);
            boolean _not = (!_isSubTypeOf);
            if (_not) {
              boolean _isSubTypeOf_1 = ArchitectureTyping.isSubTypeOf(ArchitectureTyping.resolveType(ArchitectureTyping.determineElementType(sourceModelTypeReference)), inputTypeReference);
              boolean _not_1 = (!_isSubTypeOf_1);
              if (_not_1) {
                String _qualifiedName = ArchitectureTyping.determineElementType(sourceModelTypeReference).getQualifiedName();
                String _plus = ("Source model type " + _qualifiedName);
                String _plus_1 = (_plus + 
                  " does not match generator source type ");
                String _qualifiedName_1 = inputTypeReference.getQualifiedName();
                String _plus_2 = (_plus_1 + _qualifiedName_1);
                this.error(_plus_2, 
                  ArchitecturePackage.Literals.FRAGMENT__SOURCE_MODEL);
              }
            }
          }
          final JvmTypeReference outputTypeReference = ArchitectureTyping.determineGeneratorOutputType(((JvmGenericType)generatorJvmType));
          TargetModel _targetModel = generator.getTargetModel();
          boolean _tripleNotEquals = (_targetModel != null);
          if (_tripleNotEquals) {
            final JvmTypeReference targetModelTypeReference = ArchitectureTyping.resolveType(generator.getTargetModel());
            boolean _isSubTypeOf_2 = ArchitectureTyping.isSubTypeOf(outputTypeReference, targetModelTypeReference);
            boolean _not_2 = (!_isSubTypeOf_2);
            if (_not_2) {
              String _qualifiedName_2 = sourceModelTypeReference.getQualifiedName();
              String _plus_3 = ("Target model type " + _qualifiedName_2);
              String _plus_4 = (_plus_3 + 
                " does not match generator target type ");
              String _qualifiedName_3 = inputTypeReference.getQualifiedName();
              String _plus_5 = (_plus_4 + _qualifiedName_3);
              this.error(_plus_5, 
                ArchitecturePackage.Literals.FRAGMENT__TARGET_MODEL);
            }
          }
        } else {
          this.error("Generator expected, but illegal type found. Please check for build failures.", 
            ArchitecturePackage.Literals.FRAGMENT__REFERENCE);
        }
      } else {
        this.error("Generator expected, but illegal type found. Please check for build failures.", 
          ArchitecturePackage.Literals.FRAGMENT__REFERENCE);
      }
    }
    if (!_matched) {
      this.error("Generator expected, but illegal type found. Please check for build failures.", 
        ArchitecturePackage.Literals.FRAGMENT__REFERENCE);
    }
  }
}
